"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/utils/gpxParser.js":
/*!********************************!*\
  !*** ./src/utils/gpxParser.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parseGPX\": function() { return /* binding */ parseGPX; }\n/* harmony export */ });\n/* harmony import */ var gpxparser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gpxparser */ \"./node_modules/gpxparser/dist/GPXParser.min.js\");\n/* harmony import */ var gpxparser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gpxparser__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst parseGPX = async (file)=>{\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (event)=>{\n            try {\n                const gpx = new (gpxparser__WEBPACK_IMPORTED_MODULE_0___default())();\n                gpx.parse(event.target.result);\n                const title = gpx.tracks[0].name;\n                const points = gpx.tracks[0].points;\n                const distance = gpx.tracks[0].distance.total / 1000 // Distance in kilometers\n                ;\n                const date = points[0].time.toLocaleDateString(\"fr-FR\", {\n                    weekday: \"long\",\n                    year: \"numeric\",\n                    month: \"long\",\n                    day: \"numeric\"\n                });\n                const duration = (points[points.length - 1].time - points[0].time) / 1000 / 60;\n                const distanceData = calculateDistance(points);\n                const elevationData = points.map((point, idx)=>({\n                        time: point.time,\n                        elevation: point.ele,\n                        distance: distanceData[idx].distance\n                    }));\n                const elevationSpeedData = movingAverage(calculateElevationSpeed(points), \"elevationSpeed\", 30).map((data, idx)=>({\n                        ...data,\n                        distance: distanceData[idx].distance\n                    }));\n                const speedData = movingAverage(calculateSpeed(points), \"speed\", 30).map((data, idx)=>({\n                        ...data,\n                        distance: distanceData[idx].distance\n                    }));\n                const paceData = movingAverage(calculatePace(points), \"pace\", 30).map((data, idx)=>({\n                        ...data,\n                        distance: distanceData[idx].distance\n                    }));\n                const averageSpeed = distance / (duration / 60);\n                const minElevation = gpx.tracks[0].elevation.min;\n                const maxElevation = gpx.tracks[0].elevation.max;\n                const posElevation = gpx.tracks[0].elevation.pos;\n                resolve({\n                    date,\n                    title,\n                    distance,\n                    duration,\n                    distanceData,\n                    elevationData,\n                    elevationSpeedData,\n                    speedData,\n                    paceData,\n                    averageSpeed,\n                    minElevation,\n                    maxElevation,\n                    posElevation,\n                    fileName: file.name\n                });\n            } catch (error) {\n                reject(error);\n            }\n        };\n        reader.onerror = ()=>{\n            reject(new Error(\"Error reading the GPX file.\"));\n        };\n        reader.readAsText(file);\n    });\n};\nfunction calculatePace(points) {\n    const paceData = [];\n    for(let i = 1; i < points.length; i++){\n        const prevPoint = points[i - 1];\n        const currPoint = points[i];\n        const time1 = new Date(prevPoint.time);\n        const time2 = new Date(currPoint.time);\n        const timeDifference = (time2 - time1) / 1000 / 60 // Time difference in minutes\n        ;\n        const distance = getDistance([\n            prevPoint.lat,\n            prevPoint.lon\n        ], [\n            currPoint.lat,\n            currPoint.lon\n        ]) // Distance in kilometers\n        ;\n        const minDistance = 0.001 // 1 meter\n        ;\n        if (timeDifference > 0 && distance > minDistance) {\n            let pace = timeDifference / distance;\n            if (pace > 300) continue; // Ignore pace > 300 min/km\n            paceData.push({\n                time: currPoint.time,\n                pace\n            });\n        }\n    }\n    return paceData;\n}\nfunction calculateElevationSpeed(points) {\n    const elevationSpeedData = [];\n    for(let i = 1; i < points.length; i++){\n        const prevPoint = points[i - 1];\n        const currPoint = points[i];\n        const time1 = new Date(prevPoint.time);\n        const time2 = new Date(currPoint.time);\n        const timeDifference = (time2 - time1) / 1000 // Time difference in s\n        ;\n        const elevationDifference = currPoint.ele - prevPoint.ele // Elevation difference in meters\n        ;\n        const elevationSpeed = elevationDifference * 60 * 60 / timeDifference // Elevation speed in m/h\n        ;\n        elevationSpeedData.push({\n            time: currPoint.time,\n            elevationSpeed\n        });\n    }\n    return elevationSpeedData;\n}\nfunction calculateDistance(points) {\n    const distanceData = [];\n    let totalDistance = 0;\n    for(let i = 1; i < points.length; i++){\n        const prevPoint = points[i - 1];\n        const currPoint = points[i];\n        const distance = getDistance([\n            prevPoint.lat,\n            prevPoint.lon\n        ], [\n            currPoint.lat,\n            currPoint.lon\n        ]) // Distance in kilometers\n        ;\n        totalDistance += distance;\n        distanceData.push({\n            time: currPoint.time,\n            distance: totalDistance\n        });\n    }\n    return distanceData;\n}\nfunction calculateSpeed(points) {\n    const speedData = [];\n    for(let i = 1; i < points.length; i++){\n        const prevPoint = points[i - 1];\n        const currPoint = points[i];\n        const time1 = new Date(prevPoint.time);\n        const time2 = new Date(currPoint.time);\n        const timeDifference = (time2 - time1) / 1000 * 60 * 60 // Time difference in minutes\n        ;\n        const distance = getDistance([\n            prevPoint.lat,\n            prevPoint.lon\n        ], [\n            currPoint.lat,\n            currPoint.lon\n        ]) // Distance in kilometers\n        ;\n        const speed = distance * timeDifference // Speed in km/h\n        ;\n        if (speed < 1000) {\n            speedData.push({\n                time: currPoint.time,\n                speed\n            });\n        }\n    }\n    return speedData;\n}\nfunction getDistance(point1, point2) {\n    const [lat1, lon1] = point1;\n    const [lat2, lon2] = point2;\n    const R = 6371 // Earth's radius in km\n    ;\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLon = (lon2 - lon1) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n}\nfunction movingAverage(data, valueKey, windowSize) {\n    const result = [];\n    for(let i = 0; i < data.length - windowSize + 1; i++){\n        const windowData = data.slice(i, i + windowSize);\n        const average = windowData.reduce((sum, value)=>sum + value[valueKey], 0) / windowSize;\n        result.push({\n            time: windowData[windowSize - 1].time,\n            [valueKey]: parseFloat(average.toFixed(2))\n        });\n    }\n    return result;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUwsS0FBS0MsRUFBRSxHQUFJLE9BQzVCRCxLQUFLSSxHQUFHLENBQUNGLE9BQU8sS0FDaEJGLEtBQUtJLEdBQUcsQ0FBQ0YsT0FBTztJQUVwQixNQUFNSSxJQUFJLElBQUlOLEtBQUtPLEtBQUssQ0FBQ1AsS0FBS1EsSUFBSSxDQUFDTCxJQUFJSCxLQUFLUSxJQUFJLENBQUMsSUFBSUw7SUFDckQsT0FBT0wsSUFBSVE7QUFDYjtBQUdBLFNBQVNsRCxjQUFjRSxJQUFJLEVBQUVtRCxRQUFRLEVBQUVDLFVBQVUsRUFBRTtJQUNqRCxNQUFNL0UsU0FBUyxFQUFFO0lBQ2pCLElBQUssSUFBSTRDLElBQUksR0FBR0EsSUFBSWpCLEtBQUtaLE1BQU0sR0FBR2dFLGFBQWEsR0FBR25DLElBQUs7UUFDckQsTUFBTW9DLGFBQWFyRCxLQUFLc0QsS0FBSyxDQUFDckMsR0FBR0EsSUFBSW1DO1FBQ3JDLE1BQU1HLFVBQ0pGLFdBQVdHLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxRQUFVRCxNQUFNQyxLQUFLLENBQUNQLFNBQVMsRUFBRSxLQUFLQztRQUNoRS9FLE9BQU93RCxJQUFJLENBQUM7WUFDVmhELE1BQU13RSxVQUFVLENBQUNELGFBQWEsRUFBRSxDQUFDdkUsSUFBSTtZQUNyQyxDQUFDc0UsU0FBUyxFQUFFUSxXQUFXSixRQUFRSyxPQUFPLENBQUM7UUFDekM7SUFDRjtJQUNBLE9BQU92RjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9ncHhQYXJzZXIuanM/YWM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ3B4UGFyc2VyIGZyb20gXCJncHhwYXJzZXJcIlxuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSBcImRhdGUtZm5zXCJcblxuZXhwb3J0IGNvbnN0IHBhcnNlR1BYID0gYXN5bmMgKGZpbGUpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgcmVhZGVyLm9ubG9hZCA9IChldmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZ3B4ID0gbmV3IGdweFBhcnNlcigpXG4gICAgICAgIGdweC5wYXJzZShldmVudC50YXJnZXQucmVzdWx0KVxuXG4gICAgICAgIGNvbnN0IHRpdGxlID0gZ3B4LnRyYWNrc1swXS5uYW1lXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IGdweC50cmFja3NbMF0ucG9pbnRzXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gZ3B4LnRyYWNrc1swXS5kaXN0YW5jZS50b3RhbCAvIDEwMDAgLy8gRGlzdGFuY2UgaW4ga2lsb21ldGVyc1xuXG4gICAgICAgIGNvbnN0IGRhdGUgPSBwb2ludHNbMF0udGltZS50b0xvY2FsZURhdGVTdHJpbmcoXCJmci1GUlwiLCB7XG4gICAgICAgICAgd2Vla2RheTogXCJsb25nXCIsXG4gICAgICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICAgICAgbW9udGg6IFwibG9uZ1wiLFxuICAgICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9XG4gICAgICAgICAgKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0udGltZSAtIHBvaW50c1swXS50aW1lKSAvIDEwMDAgLyA2MFxuXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlRGF0YSA9IGNhbGN1bGF0ZURpc3RhbmNlKHBvaW50cylcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGVsZXZhdGlvbkRhdGEgPSBwb2ludHMubWFwKChwb2ludCxpZHgpID0+ICh7XG4gICAgICAgICAgdGltZTogcG9pbnQudGltZSxcbiAgICAgICAgICBlbGV2YXRpb246IHBvaW50LmVsZSxcbiAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2VEYXRhW2lkeF0uZGlzdGFuY2VcbiAgICAgICAgfSkpXG5cbiAgICAgXG4gICAgICBjb25zdCBlbGV2YXRpb25TcGVlZERhdGEgPSBtb3ZpbmdBdmVyYWdlKGNhbGN1bGF0ZUVsZXZhdGlvblNwZWVkKHBvaW50cyksIFwiZWxldmF0aW9uU3BlZWRcIiwgMzApXG4gICAgICAgIC5tYXAoKGRhdGEsIGlkeCkgPT4gKHsgLi4uZGF0YSwgZGlzdGFuY2U6IGRpc3RhbmNlRGF0YVtpZHhdLmRpc3RhbmNlIH0pKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3BlZWREYXRhID0gbW92aW5nQXZlcmFnZShjYWxjdWxhdGVTcGVlZChwb2ludHMpLCBcInNwZWVkXCIsIDMwKVxuICAgICAgICAubWFwKChkYXRhLCBpZHgpID0+ICh7IC4uLmRhdGEsIGRpc3RhbmNlOiBkaXN0YW5jZURhdGFbaWR4XS5kaXN0YW5jZSB9KSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHBhY2VEYXRhID0gbW92aW5nQXZlcmFnZShjYWxjdWxhdGVQYWNlKHBvaW50cyksIFwicGFjZVwiLCAzMClcbiAgICAgICAgLm1hcCgoZGF0YSwgaWR4KSA9PiAoeyAuLi5kYXRhLCBkaXN0YW5jZTogZGlzdGFuY2VEYXRhW2lkeF0uZGlzdGFuY2UgfSkpO1xuICAgICAgXG4gICAgICAgIGNvbnN0IGF2ZXJhZ2VTcGVlZCA9IGRpc3RhbmNlIC8gKGR1cmF0aW9uIC8gNjApXG5cbiAgICAgICAgY29uc3QgbWluRWxldmF0aW9uID0gZ3B4LnRyYWNrc1swXS5lbGV2YXRpb24ubWluXG4gICAgICAgIGNvbnN0IG1heEVsZXZhdGlvbiA9IGdweC50cmFja3NbMF0uZWxldmF0aW9uLm1heFxuICAgICAgICBjb25zdCBwb3NFbGV2YXRpb24gPSBncHgudHJhY2tzWzBdLmVsZXZhdGlvbi5wb3NcblxuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICBkYXRlLFxuICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgIGRpc3RhbmNlRGF0YSxcbiAgICAgICAgICBlbGV2YXRpb25EYXRhLFxuICAgICAgICAgIGVsZXZhdGlvblNwZWVkRGF0YSxcbiAgICAgICAgICBzcGVlZERhdGEsXG4gICAgICAgICAgcGFjZURhdGEsXG4gICAgICAgICAgYXZlcmFnZVNwZWVkLFxuICAgICAgICAgIG1pbkVsZXZhdGlvbixcbiAgICAgICAgICBtYXhFbGV2YXRpb24sXG4gICAgICAgICAgcG9zRWxldmF0aW9uLFxuICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWVcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJFcnJvciByZWFkaW5nIHRoZSBHUFggZmlsZS5cIikpXG4gICAgfVxuXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUGFjZShwb2ludHMpIHtcbiAgY29uc3QgcGFjZURhdGEgPSBbXVxuICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZXZQb2ludCA9IHBvaW50c1tpIC0gMV1cbiAgICBjb25zdCBjdXJyUG9pbnQgPSBwb2ludHNbaV1cblxuICAgIGNvbnN0IHRpbWUxID0gbmV3IERhdGUocHJldlBvaW50LnRpbWUpXG4gICAgY29uc3QgdGltZTIgPSBuZXcgRGF0ZShjdXJyUG9pbnQudGltZSlcbiAgICBjb25zdCB0aW1lRGlmZmVyZW5jZSA9ICh0aW1lMiAtIHRpbWUxKSAvIDEwMDAgLyA2MCAvLyBUaW1lIGRpZmZlcmVuY2UgaW4gbWludXRlc1xuXG4gICAgY29uc3QgZGlzdGFuY2UgPSBnZXREaXN0YW5jZShcbiAgICAgIFtwcmV2UG9pbnQubGF0LCBwcmV2UG9pbnQubG9uXSxcbiAgICAgIFtjdXJyUG9pbnQubGF0LCBjdXJyUG9pbnQubG9uXVxuICAgICkgLy8gRGlzdGFuY2UgaW4ga2lsb21ldGVyc1xuXG4gICAgY29uc3QgbWluRGlzdGFuY2UgPSAwLjAwMSAvLyAxIG1ldGVyXG5cbiAgICBpZiAodGltZURpZmZlcmVuY2UgPiAwICYmIGRpc3RhbmNlID4gbWluRGlzdGFuY2UpIHtcbiAgICAgIGxldCBwYWNlID0gdGltZURpZmZlcmVuY2UgLyBkaXN0YW5jZVxuXG4gICAgICBpZiAocGFjZSA+IDMwMCkgY29udGludWUgLy8gSWdub3JlIHBhY2UgPiAzMDAgbWluL2ttXG5cbiAgICAgIHBhY2VEYXRhLnB1c2goe1xuICAgICAgICB0aW1lOiBjdXJyUG9pbnQudGltZSxcbiAgICAgICAgcGFjZVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhY2VEYXRhXG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUVsZXZhdGlvblNwZWVkKHBvaW50cykge1xuICBjb25zdCBlbGV2YXRpb25TcGVlZERhdGEgPSBbXVxuICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZXZQb2ludCA9IHBvaW50c1tpIC0gMV1cbiAgICBjb25zdCBjdXJyUG9pbnQgPSBwb2ludHNbaV1cblxuICAgIGNvbnN0IHRpbWUxID0gbmV3IERhdGUocHJldlBvaW50LnRpbWUpXG4gICAgY29uc3QgdGltZTIgPSBuZXcgRGF0ZShjdXJyUG9pbnQudGltZSlcbiAgICBjb25zdCB0aW1lRGlmZmVyZW5jZSA9ICgodGltZTIgLSB0aW1lMSkgLyAxMDAwKSAvLyBUaW1lIGRpZmZlcmVuY2UgaW4gc1xuXG4gICAgY29uc3QgZWxldmF0aW9uRGlmZmVyZW5jZSA9IChjdXJyUG9pbnQuZWxlIC0gcHJldlBvaW50LmVsZSApIC8vIEVsZXZhdGlvbiBkaWZmZXJlbmNlIGluIG1ldGVyc1xuXG4gICAgY29uc3QgZWxldmF0aW9uU3BlZWQgPSBlbGV2YXRpb25EaWZmZXJlbmNlICogNjAgKiA2MCAvIHRpbWVEaWZmZXJlbmNlIC8vIEVsZXZhdGlvbiBzcGVlZCBpbiBtL2hcblxuICAgIGVsZXZhdGlvblNwZWVkRGF0YS5wdXNoKHtcbiAgICAgIHRpbWU6IGN1cnJQb2ludC50aW1lLFxuICAgICAgZWxldmF0aW9uU3BlZWRcbiAgICB9KVxuICB9XG4gIHJldHVybiBlbGV2YXRpb25TcGVlZERhdGFcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2UocG9pbnRzKSB7XG4gIGNvbnN0IGRpc3RhbmNlRGF0YSA9IFtdXG4gIGxldCB0b3RhbERpc3RhbmNlID0gMFxuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJldlBvaW50ID0gcG9pbnRzW2kgLSAxXVxuICAgIGNvbnN0IGN1cnJQb2ludCA9IHBvaW50c1tpXVxuXG4gICAgY29uc3QgZGlzdGFuY2UgPSBnZXREaXN0YW5jZShcbiAgICAgIFtwcmV2UG9pbnQubGF0LCBwcmV2UG9pbnQubG9uXSxcbiAgICAgIFtjdXJyUG9pbnQubGF0LCBjdXJyUG9pbnQubG9uXVxuICAgICkgLy8gRGlzdGFuY2UgaW4ga2lsb21ldGVyc1xuXG4gICAgdG90YWxEaXN0YW5jZSArPSBkaXN0YW5jZVxuXG4gICAgZGlzdGFuY2VEYXRhLnB1c2goe1xuICAgICAgdGltZTogY3VyclBvaW50LnRpbWUsXG4gICAgICBkaXN0YW5jZTogdG90YWxEaXN0YW5jZVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gZGlzdGFuY2VEYXRhXG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwZWVkKHBvaW50cykge1xuICBjb25zdCBzcGVlZERhdGEgPSBbXVxuICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZXZQb2ludCA9IHBvaW50c1tpIC0gMV1cbiAgICBjb25zdCBjdXJyUG9pbnQgPSBwb2ludHNbaV1cblxuICAgIGNvbnN0IHRpbWUxID0gbmV3IERhdGUocHJldlBvaW50LnRpbWUpXG4gICAgY29uc3QgdGltZTIgPSBuZXcgRGF0ZShjdXJyUG9pbnQudGltZSlcbiAgICBjb25zdCB0aW1lRGlmZmVyZW5jZSA9ICgodGltZTIgLSB0aW1lMSkgLyAxMDAwKSAqIDYwICogNjAgLy8gVGltZSBkaWZmZXJlbmNlIGluIG1pbnV0ZXNcblxuICAgIGNvbnN0IGRpc3RhbmNlID0gZ2V0RGlzdGFuY2UoXG4gICAgICBbcHJldlBvaW50LmxhdCwgcHJldlBvaW50Lmxvbl0sXG4gICAgICBbY3VyclBvaW50LmxhdCwgY3VyclBvaW50Lmxvbl1cbiAgICApIC8vIERpc3RhbmNlIGluIGtpbG9tZXRlcnNcblxuICAgIGNvbnN0IHNwZWVkID0gZGlzdGFuY2UgKiB0aW1lRGlmZmVyZW5jZSAvLyBTcGVlZCBpbiBrbS9oXG5cbiAgICBpZiAoc3BlZWQgPCAxMDAwKSB7XG4gICAgICBzcGVlZERhdGEucHVzaCh7XG4gICAgICAgIHRpbWU6IGN1cnJQb2ludC50aW1lLFxuICAgICAgICBzcGVlZFxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNwZWVkRGF0YVxufVxuXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwb2ludDEsIHBvaW50Mikge1xuICBjb25zdCBbbGF0MSwgbG9uMV0gPSBwb2ludDFcbiAgY29uc3QgW2xhdDIsIGxvbjJdID0gcG9pbnQyXG5cbiAgY29uc3QgUiA9IDYzNzEgLy8gRWFydGgncyByYWRpdXMgaW4ga21cbiAgY29uc3QgZExhdCA9ICgobGF0MiAtIGxhdDEpICogTWF0aC5QSSkgLyAxODBcbiAgY29uc3QgZExvbiA9ICgobG9uMiAtIGxvbjEpICogTWF0aC5QSSkgLyAxODBcblxuICBjb25zdCBhID1cbiAgICBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xuICAgIE1hdGguY29zKChsYXQxICogTWF0aC5QSSkgLyAxODApICpcbiAgICAgIE1hdGguY29zKChsYXQyICogTWF0aC5QSSkgLyAxODApICpcbiAgICAgIE1hdGguc2luKGRMb24gLyAyKSAqXG4gICAgICBNYXRoLnNpbihkTG9uIC8gMilcblxuICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKVxuICByZXR1cm4gUiAqIGNcbn1cblxuXG5mdW5jdGlvbiBtb3ZpbmdBdmVyYWdlKGRhdGEsIHZhbHVlS2V5LCB3aW5kb3dTaXplKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSB3aW5kb3dTaXplICsgMTsgaSsrKSB7XG4gICAgY29uc3Qgd2luZG93RGF0YSA9IGRhdGEuc2xpY2UoaSwgaSArIHdpbmRvd1NpemUpXG4gICAgY29uc3QgYXZlcmFnZSA9XG4gICAgICB3aW5kb3dEYXRhLnJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWVbdmFsdWVLZXldLCAwKSAvIHdpbmRvd1NpemVcbiAgICByZXN1bHQucHVzaCh7XG4gICAgICB0aW1lOiB3aW5kb3dEYXRhW3dpbmRvd1NpemUgLSAxXS50aW1lLFxuICAgICAgW3ZhbHVlS2V5XTogcGFyc2VGbG9hdChhdmVyYWdlLnRvRml4ZWQoMikpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG4iXSwibmFtZXMiOlsiZ3B4UGFyc2VyIiwiZm9ybWF0IiwicGFyc2VHUFgiLCJmaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiZXZlbnQiLCJncHgiLCJwYXJzZSIsInRhcmdldCIsInJlc3VsdCIsInRpdGxlIiwidHJhY2tzIiwibmFtZSIsInBvaW50cyIsImRpc3RhbmNlIiwidG90YWwiLCJkYXRlIiwidGltZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIndlZWtkYXkiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJkdXJhdGlvbiIsImxlbmd0aCIsImRpc3RhbmNlRGF0YSIsImNhbGN1bGF0ZURpc3RhbmNlIiwiZWxldmF0aW9uRGF0YSIsIm1hcCIsInBvaW50IiwiaWR4IiwiZWxldmF0aW9uIiwiZWxlIiwiZWxldmF0aW9uU3BlZWREYXRhIiwibW92aW5nQXZlcmFnZSIsImNhbGN1bGF0ZUVsZXZhdGlvblNwZWVkIiwiZGF0YSIsInNwZWVkRGF0YSIsImNhbGN1bGF0ZVNwZWVkIiwicGFjZURhdGEiLCJjYWxjdWxhdGVQYWNlIiwiYXZlcmFnZVNwZWVkIiwibWluRWxldmF0aW9uIiwibWluIiwibWF4RWxldmF0aW9uIiwibWF4IiwicG9zRWxldmF0aW9uIiwicG9zIiwiZmlsZU5hbWUiLCJlcnJvciIsIm9uZXJyb3IiLCJFcnJvciIsInJlYWRBc1RleHQiLCJpIiwicHJldlBvaW50IiwiY3VyclBvaW50IiwidGltZTEiLCJEYXRlIiwidGltZTIiLCJ0aW1lRGlmZmVyZW5jZSIsImdldERpc3RhbmNlIiwibGF0IiwibG9uIiwibWluRGlzdGFuY2UiLCJwYWNlIiwicHVzaCIsImVsZXZhdGlvbkRpZmZlcmVuY2UiLCJlbGV2YXRpb25TcGVlZCIsInRvdGFsRGlzdGFuY2UiLCJzcGVlZCIsInBvaW50MSIsInBvaW50MiIsImxhdDEiLCJsb24xIiwibGF0MiIsImxvbjIiLCJSIiwiZExhdCIsIk1hdGgiLCJQSSIsImRMb24iLCJhIiwic2luIiwiY29zIiwiYyIsImF0YW4yIiwic3FydCIsInZhbHVlS2V5Iiwid2luZG93U2l6ZSIsIndpbmRvd0RhdGEiLCJzbGljZSIsImF2ZXJhZ2UiLCJyZWR1Y2UiLCJzdW0iLCJ2YWx1ZSIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/gpxParser.js\n"));

/***/ })

});